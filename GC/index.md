# 1. Сборщик мусора в C#

Для ссылочных типов:
- значение хранится в куче
- ссылка хранится в стеке, но она содержит адрес на участок памяти в куче
- когда стек очищается, на значение в куче никто не ссылается и это приводит к очистке участка в памяти, но не немедленной

Сборщик мусора запускается не сразу после удаления ссылки из стека, он запускается в то время, когда CLR найдет в этом потребность, к примеру когда программе потребуется дополнительная память.

Для крупных объектов есть своя куча - Large Object Heap (размеры объектов больше 85000 байт)

Все объекты в куче разделяются по поколениям:
- 0-е - новые объекты, которые ни разу не подвергались сборке мусора
- 1-e - объекты, которые пережили одну сборку
- 2-е - объекты, прошедшие более 1-ой сборки

Когда сборщик мусора приступает к работе, то сначала он анализирует 0-е поколение. Те объекты, которые остаются еще актуальными помещаются в 1-е поколение.

Если после обработки 0-го поколения необходима дополнительная память, то сборщик приступает к объектам 1-го поколения

## 1.1 Класс System.GC

- класс, который опеределяет функционал сборщика

# 2. Финализируемые объекты

- управляемые объекты - управляются CLR и легко очищаются
- неуправляемые объекты - CLR не знает как очищать такие данные

Для освобождения неуправляемых ресурсов есть два механизма:
- создание деструктора
- реализация интерфейса IDisposable

## 2.1 Создание деструктора

- определяются только в классах
- класс может иметь только один деструктор

```csharp
~Person()
    {
        Console.WriteLine($"{Name} has deleted");
    }
```

На деле GC вызывает не деструктор, а метод Finalize, т.к. компилятор компилирует деструктор в конструкцию

Метод Finalize определен для всех типов класса Object

```csharp
protected override void Finalize()
{
    try
    {
        // здесь идут инструкции деструктора
    }
    finally
    {
        base.Finalize();
    }
}
```

GC при размещении объекта в куче определяет, поддерживает ли данный объект метод Finalize. Если да, то указатель на него сохраняется в специальной таблице, которая называется очередь финализации. Когда начинается момент сборки GC видит, что объект должен быть уничтожен, и если он имеет метод Finalize, то он копирует объект в еще одну таблицу и уничтожается при следующем проходе сборки

Проблема в том, что время вызова деструктора не определено.
Также еси есть два связанных ообъекта, то порядок выхова деструктора не гаранитруется

## 2.2 Интерфейс IDisposable

- метод Dispose 
- немедленно вызвает деструктор и освобождает все связанные с объектом неуправляемые ресурсы

# 3. Конструкция using

- для автоматического выхова метода Dispose
- класс должен реализовать интерфейс IDisposable

```csharp
using (Person tom = new Person("Tom"))
{
}
```

## 3.1 Освобождение множества ресурсов

- Для освобождения множества ресурсов мы можем применять вложенные конструкции using.

```csharp
void Test()
{
    using (Person tom = new Person("Tom"))
    {
        using (Person bob = new Person("Bob"))
        {
            Console.WriteLine($"Person1: {tom.Name}    Person2: {bob.Name}");
        }// вызов метода Dispose для объекта bob
    } // вызов метода Dispose для объекта tom
    Console.WriteLine("Конец метода Test");
}
```